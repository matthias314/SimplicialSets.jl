<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simplices · SimplicialSets.jl</title><meta name="title" content="Simplices · SimplicialSets.jl"/><meta property="og:title" content="Simplices · SimplicialSets.jl"/><meta property="twitter:title" content="Simplices · SimplicialSets.jl"/><meta name="description" content="Documentation for SimplicialSets.jl."/><meta property="og:description" content="Documentation for SimplicialSets.jl."/><meta property="twitter:description" content="Documentation for SimplicialSets.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SimplicialSets.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Simplices</a><ul class="internal"><li><a class="tocitem" href="#AbstractSimplex"><span><code>AbstractSimplex</code></span></a></li><li><a class="tocitem" href="#SymbolicSimplex"><span><code>SymbolicSimplex</code></span></a></li><li><a class="tocitem" href="#ProductSimplex"><span><code>ProductSimplex</code></span></a></li><li><a class="tocitem" href="#BarSimplex"><span><code>BarSimplex</code></span></a></li><li><a class="tocitem" href="#LoopGroupSimplex"><span><code>LoopGroupSimplex</code></span></a></li><li><a class="tocitem" href="#Other-simplices"><span>Other simplices</span></a></li></ul></li><li><a class="tocitem" href="../basic/">Basic functions for simplices</a></li><li><a class="tocitem" href="../ez/">Eilenberg–Zilber maps</a></li><li><a class="tocitem" href="../surjection/">Surjection operad and interval cuts</a></li><li><a class="tocitem" href="../helpers/">Helper types for groups</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simplices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simplices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/matthias314/SimplicialSets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/matthias314/SimplicialSets.jl/blob/master/docs/src/simplices.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simplices"><a class="docs-heading-anchor" href="#Simplices">Simplices</a><a id="Simplices-1"></a><a class="docs-heading-anchor-permalink" href="#Simplices" title="Permalink"></a></h1><h2 id="AbstractSimplex"><a class="docs-heading-anchor" href="#AbstractSimplex"><code>AbstractSimplex</code></a><a id="AbstractSimplex-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractSimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.AbstractSimplex" href="#SimplicialSets.AbstractSimplex"><code>SimplicialSets.AbstractSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSimplex &lt;: Any</code></pre><p>This is the supertype of all types representing simplices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/abstract.jl#L15-L19">source</a></section></article><h2 id="SymbolicSimplex"><a class="docs-heading-anchor" href="#SymbolicSimplex"><code>SymbolicSimplex</code></a><a id="SymbolicSimplex-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicSimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.SymbolicSimplex" href="#SimplicialSets.SymbolicSimplex"><code>SimplicialSets.SymbolicSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymbolicSimplex{L&lt;:Union{Symbol,Char}} &lt;: AbstractSimplex

SymbolicSimplex(label, w::AbstractVector{&lt;:Integer})
SymbolicSimplex(label, n::Integer)</code></pre><p>This type represents &quot;symbolic simplices&quot; that are given by a label and a weakly increasing sequence of non-negative integers enumerating the vertices. Such a simplex is degenerate if any integer is repeated.</p><p>The label can be of type <code>Symbol</code> or <code>Char</code>. The vertex numbers must be between <code>0</code> and <code>31</code>, and the dimension cannot be larger than <code>24</code>. If an integer <code>n</code> is passed as a second argument to the constructor, then the vertices are <code>0:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/symbolic.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.vertices" href="#SimplicialSets.vertices"><code>SimplicialSets.vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertices(x::SymbolicSimplex) -&gt; Vector{Int}</code></pre><p>Return the vertices of <code>x</code> as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/symbolic.jl#L73-L77">source</a></section></article><h2 id="ProductSimplex"><a class="docs-heading-anchor" href="#ProductSimplex"><code>ProductSimplex</code></a><a id="ProductSimplex-1"></a><a class="docs-heading-anchor-permalink" href="#ProductSimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.ProductSimplex" href="#SimplicialSets.ProductSimplex"><code>SimplicialSets.ProductSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductSimplex{T&lt;:Tuple{Vararg{AbstractSimplex}}} &lt;: AbstractSimplex

ProductSimplex{T}{t::Tuple{Vararg{AbstractSimplex}} [; dim::Integer]}

ProductSimplex(t::Tuple{Vararg{AbstractSimplex}} [; dim::Integer])
ProductSimplex(xs::AbstractSimplex... [; dim::Integer])</code></pre><p>A type representing an element in the product of simplicial sets. Empty products are allowed. The component simplices must all be of the same dimension. They may be given as a tuple or as individual arguments.</p><p>In the case of the empty product, the keyword argument <code>dim</code> is required to determine the dimension of the resulting simplex. Otherwise <code>dim</code> is optional, but if present, it must be correct.</p><p>See also <a href="#Core.Tuple-Tuple{ProductSimplex}"><code>Tuple(x::ProductSimplex)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x, y = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2)
(x[0,1,2], y[0,1,2])

julia&gt; z = ProductSimplex(x, y)
(x[0,1,2],y[0,1,2])

julia&gt; w = ProductSimplex(dim = 2)
()

julia&gt; dim(w)
2

julia&gt; ProductSimplex(x, y; dim = 1)
ERROR: dimensions of simplices do not match
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L12-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Tuple-Tuple{ProductSimplex}" href="#Core.Tuple-Tuple{ProductSimplex}"><code>Core.Tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Tuple(x::ProductSimplex{T}) where T &lt;: Tuple{Vararg{AbstractSimplex}} -&gt; T</code></pre><p>Return the tuple of component simplices of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{ProductSimplex}" href="#Base.length-Tuple{ProductSimplex}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(x::ProductSimplex) -&gt; Int</code></pre><p>Return the number of components (or factors) of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.cat" href="#LinearCombinations.cat"><code>LinearCombinations.cat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SimplicialSets.cat(x::ProductSimplex...) -&gt; ProductSimplex</code></pre><p>Return the product simplex that is the concatenation of the simplices given as arguments.</p><p>This function is linear. Also note that it is overloaded from the package <code>LinearCombinations</code>, not from <code>Base</code>. If one wants to use the short form <code>cat</code>, then one needs to import the function via <code>using</code> or <code>import</code>.</p><p>See also <a href="#LinearCombinations.flatten"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: cat   # or: using LinearCombinations: cat

julia&gt; u = ProductSimplex(SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2))
(x[0,1],y[0,1])

julia&gt; v = ProductSimplex(SymbolicSimplex(:z, 2), SymbolicSimplex(:w, 2))
(z[0,1],w[0,1])

julia&gt; cat(u, v)
(x[0,1],y[0,1],z[0,1],w[0,1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L148-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.flatten" href="#LinearCombinations.flatten"><code>LinearCombinations.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SimplicialSets.flatten(x::ProductSimplex) -&gt; ProductSimplex</code></pre><p>Return the product simplex that is obtained by recursively flattening all product simplices appearing within <code>x</code>.</p><p>This function is linear. Also note that it is overloaded from the package <code>LinearCombinations</code>.</p><p>See also <a href="#LinearCombinations.Regroup"><code>LinearCombinations.Regroup</code></a>, <a href="#LinearCombinations.cat"><code>SimplicialSets.cat</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: flatten   # or: using LinearCombinations: flatten

julia&gt; u = ProductSimplex(SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2))
(x[0,1],y[0,1])

julia&gt; v = ProductSimplex(SymbolicSimplex(:z, 2), SymbolicSimplex(:w, 2))
(z[0,1],w[0,1])

julia&gt; flatten(ProductSimplex(u, v))
(x[0,1],y[0,1],z[0,1],w[0,1])

julia&gt; flatten(ProductSimplex(ProductSimplex(u, v), u))
(x[0,1],y[0,1],z[0,1],w[0,1],x[0,1],y[0,1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L177-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.swap" href="#LinearCombinations.swap"><code>LinearCombinations.swap</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">swap(z::ProductSimplex{Tuple{S,T}}) where {S &lt;: AbstractSimplex, T &lt;: AbstractSimplex} -&gt; ProductSimplex{Tuple{T,S}}</code></pre><p>Swap the two components of the <code>ProductSimplex</code> <code>z</code> and return the resulting <code>ProductSimplex</code>.</p><p>This function is linear. Also note that it is overloaded from the package <code>LinearCombinations</code>.</p><p>See also <a href="#LinearCombinations.Regroup"><code>LinearCombinations.Regroup</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L217-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearCombinations.Regroup" href="#LinearCombinations.Regroup"><code>LinearCombinations.Regroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(rg::LinearCombinations.Regroup)(z::ProductSimplex) -&gt; ProductSimplex</code></pre><p>Apply the <code>Regroup</code> element <code>rg</code> to <code>z</code> and return the result. This allows to permute and restructure the components of a product simplex in an arbitrary way (without dropping any component).</p><p>This functions is linear and supports the keyword arguments <code>coefftype</code>, <code>addto</code>, <code>coeff</code> and <code>is_filtered</code> as described for <code>@linear</code>.</p><p>See <code>LinearCombinations.@linear</code>, <code>LinearCombinations.regroup</code>, <a href="#LinearCombinations.swap"><code>swap</code></a>, <a href="#LinearCombinations.flatten"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; using LinearCombinations

julia&gt; rg = regroup(:( ((1, 2), 3) ), :( (2, (3, 1))  ))
Regroup{((1, 2), 3),(2, (3, 1))}

julia&gt; x, y, z = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2), SymbolicSimplex(:z, 2)
(x[0,1,2], y[0,1,2], z[0,1,2])

julia&gt; w = ProductSimplex(ProductSimplex(x, y), z)
((x[0,1,2],y[0,1,2]),z[0,1,2])

julia&gt; rg(w)
(y[0,1,2],(z[0,1,2],x[0,1,2]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/product.jl#L228-L256">source</a></section></article><h2 id="BarSimplex"><a class="docs-heading-anchor" href="#BarSimplex"><code>BarSimplex</code></a><a id="BarSimplex-1"></a><a class="docs-heading-anchor-permalink" href="#BarSimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.BarSimplex" href="#SimplicialSets.BarSimplex"><code>SimplicialSets.BarSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BarSimplex{T} &lt;: AbstractSimplex

BarSimplex(iter; op::Union{typeof(*),typeof(+)} = *) -&gt; BarSimplex</code></pre><p>A type representing simplices in a simplicial bar construction. If <code>T</code> is a subtype of <code>AbstractSimplex</code>, then it is assumed to be a simplicial group; otherwise <code>T</code> is assumed to be a multiplicative discrete group.</p><p>The constructor accepts an iterator over the components of the bar simplex. The optional keyword <code>op</code> indicates whether the group is multiplicative (default) or additive.</p><p>Iterating over a <code>BarSimplex</code> means iterating over its components.</p><p>See also <a href="../helpers/#SimplicialSets.AddToMul"><code>AddToMul</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: d, s

julia&gt; b = BarSimplex([Lattice(1, 2), Lattice(3, 4)]; op = +)
[(1, 2),(3, 4)]

julia&gt; d(b, 0)
[(3, 4)]

julia&gt; d(b, 1)
[(4, 6)]

julia&gt; s(b, 1)
[(1, 2),(0, 0),(3, 4)]

julia&gt; collect(b)
2-element Vector{AddToMul{Lattice{2}}}:
 (1, 2)
 (3, 4)

julia&gt; b1 = BarSimplex([Lattice(1, 2)]; op = +)
[(1, 2)]

julia&gt; b0 = BarSimplex(Lattice{2}[]; op = +)
[]

julia&gt; c = BarSimplex([b0, b1])
[[],[(1, 2)]]

julia&gt; s(c, 1)
[[],[(0, 0)],[(0, 0),(1, 2)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L10-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{BarSimplex}" href="#Base.length-Tuple{BarSimplex}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(x::BarSimplex) -&gt; Int</code></pre><p>The length of a <code>BarSimplex</code> is the number of its components.</p><p>See also <a href="../helpers/#Core.Tuple-Tuple{Lattice}"><code>Tuple(::BarSimplex)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.one-Tuple{BarSimplex}" href="#Base.one-Tuple{BarSimplex}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one(x::BarSimplex{T}, n::Integer = dim(x)) where T -&gt; BarSimplex{T}</code></pre><p>Return the identity element in the group of <code>n</code>-simplices in the simplicial bar construction containing <code>x</code>. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isone-Tuple{BarSimplex}" href="#Base.isone-Tuple{BarSimplex}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(x::BarSimplex{T}) where T -&gt; Bool</code></pre><p>Return <code>true</code> if <code>x</code> is the identity element in the group of bar simplices of dimension equal to the dimension of <code>x</code>. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{BarSimplex{T}, Vararg{BarSimplex{T}}}} where T" href="#Base.:*-Union{Tuple{T}, Tuple{BarSimplex{T}, Vararg{BarSimplex{T}}}} where T"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::BarSimplex{T}...) where T -&gt; BarSimplex{T}</code></pre><p>Return the product of the given simplices, which must all have the same dimension. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{BarSimplex}" href="#Base.inv-Tuple{BarSimplex}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(x::BarSimplex{T}) where T -&gt; BarSimplex{T}</code></pre><p>Return the inverse element of <code>x</code> in the group of <code>n</code>-simplices in the simplicial bar construction containing that simplex. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{BarSimplex{T}, BarSimplex{T}}} where T" href="#Base.:/-Union{Tuple{T}, Tuple{BarSimplex{T}, BarSimplex{T}}} where T"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">/(x::BarSimplex{T}, y::BarSimplex{T}) where T -&gt; BarSimplex{T}</code></pre><p>Return the quotient of the <code>x</code> by <code>y</code> in the commutative group of <code>n</code>-simplices in the simplicial bar construction, where <code>n</code> is the common dimension of <code>x</code> and <code>y</code>. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:^-Tuple{BarSimplex, Integer}" href="#Base.:^-Tuple{BarSimplex, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(x::BarSimplex{T}, n::Integer) where T -&gt; BarSimplex{T}</code></pre><p>Return the <code>n</code>-th power of the simplex <code>x</code>. Here <code>T</code> is assumed to be a commutative (simplicial) group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/bar.jl#L142-L147">source</a></section></article><h2 id="LoopGroupSimplex"><a class="docs-heading-anchor" href="#LoopGroupSimplex"><code>LoopGroupSimplex</code></a><a id="LoopGroupSimplex-1"></a><a class="docs-heading-anchor-permalink" href="#LoopGroupSimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.LoopGroupGenerator" href="#SimplicialSets.LoopGroupGenerator"><code>SimplicialSets.LoopGroupGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplicalSets.LoopGroupGenerator{T &lt;: AbstractSimplex}</code></pre><p>This type represents multiplicative generators of the loop group of the simplicial set with simplices of type <code>T</code>. An element of type <code>LoopGroupGenerator{T}</code> is a pair of a simplex <code>gen</code> of type <code>T</code> and <code>Bool</code> value <code>inv</code>. The latter indicates whether this element represents generator corresponding to <code>gen</code> (<code>inv == false</code>) or its inverse (<code>inv == true</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: LoopGroupGenerator

julia&gt; x = SymbolicSimplex(:x, 2)
x[0,1,2]

julia&gt; LoopGroupGenerator(x, false)
x[0,1,2]

julia&gt; LoopGroupGenerator(x, true)
x[0,1,2]⁻¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L10-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.LoopGroupSimplex" href="#SimplicialSets.LoopGroupSimplex"><code>SimplicialSets.LoopGroupSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LoopGroupSimplex{T&lt;:AbstractSimplex} &lt;: AbstractSimplex

LoopGroupSimplex(x::T) where T &lt;: AbstractSimplex</code></pre><p>This type represents simplices in the Kan loop groups of the simplicial set with elements of type <code>T</code>. The latter simplicial set is assume to be reduced, meaning that it contains a single simplex of dimension <code>0</code>.</p><p>The constructor returns the simplex in the loop group determined by the simplex <code>x</code>, which must be of strictly positive dimension.</p><p>Iterating over a <code>LoopGroupSimplex{T}</code> yields its components, which are of type <code>LoopGroupGenerator{T}</code>.</p><p>See also <a href="#SimplicialSets.LoopGroupGenerator"><code>SimplicialSets.LoopGroupGenerator</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: s, d

julia&gt; x = SymbolicSimplex(:x, 2); y = LoopGroupSimplex(x)
⟨x[0,1,2]⟩

julia&gt; d(y, 1), d(y, 0)
(⟨x[0,1]⟩, ⟨x[1,2]⁻¹,x[0,2]⟩)

julia&gt; LoopGroupSimplex(s(x, 0))
⟨⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L64-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{LoopGroupSimplex}" href="#Base.length-Tuple{LoopGroupSimplex}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(x::LoopGroupSimplex) -&gt; Int</code></pre><p>The length of a <code>LoopGroupSimplex</code> is the number of its components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isone-Tuple{LoopGroupSimplex}" href="#Base.isone-Tuple{LoopGroupSimplex}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(x::LoopGroupSimplex{T}) where T -&gt; Bool</code></pre><p>Return <code>true</code> if <code>x</code> is the identity element in the loop group simplices of dimension equal to the dimension of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{LoopGroupSimplex}" href="#Base.inv-Tuple{LoopGroupSimplex}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.inv(g::L) where L &lt;: LoopGroupSimplex -&gt; L</code></pre><p>Return the inverse of the simplex <code>g</code> in the loop group.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g, h = LoopGroupSimplex(SymbolicSimplex(:x, 2)), LoopGroupSimplex(SymbolicSimplex(:y, 2))
(⟨x[0,1,2]⟩, ⟨y[0,1,2]⟩)

julia&gt; inv(g*h)
⟨y[0,1,2]⁻¹,x[0,1,2]⁻¹⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L191-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.mul!" href="#SimplicialSets.mul!"><code>SimplicialSets.mul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SimplicialSets.mul!(g::L, hs::L...) where L &lt;: LoopGroupSimplex</code></pre><p>Multiply the simplex <code>g</code> from the right by the simplices given as other arguments in-place and return <code>g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = LoopGroupSimplex(SymbolicSimplex(:x, 2))
⟨x[0,1,2]⟩

julia&gt; h = LoopGroupSimplex(SymbolicSimplex(:y, 2))
⟨y[0,1,2]⟩

julia&gt; SimplicialSets.mul!(g, h)
⟨x[0,1,2],y[0,1,2]⟩

julia&gt; g
⟨x[0,1,2],y[0,1,2]⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L213-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{LoopGroupSimplex{T}, Vararg{LoopGroupSimplex{T}}}} where T&lt;:AbstractSimplex" href="#Base.:*-Union{Tuple{T}, Tuple{LoopGroupSimplex{T}, Vararg{LoopGroupSimplex{T}}}} where T&lt;:AbstractSimplex"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(g::L...) where L &lt;: LoopGroupSimplex -&gt; L</code></pre><p>Multiply the given simplices in the loop group. At least one simplex must be given, and they must all have the same dimension.</p><p>See also <a href="#SimplicialSets.mul!"><code>SimplicialSets.mul!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = LoopGroupSimplex(SymbolicSimplex(:x, 2))
⟨x[0,1,2]⟩

julia&gt; h = LoopGroupSimplex(SymbolicSimplex(:y, 2))
⟨y[0,1,2]⟩

julia&gt; g*h
⟨x[0,1,2],y[0,1,2]⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/loopgroup.jl#L243-L262">source</a></section></article><h2 id="Other-simplices"><a class="docs-heading-anchor" href="#Other-simplices">Other simplices</a><a id="Other-simplices-1"></a><a class="docs-heading-anchor-permalink" href="#Other-simplices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.IntervalSimplex" href="#SimplicialSets.IntervalSimplex"><code>SimplicialSets.IntervalSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalSimplex &lt;: AbstractSimplex

IntervalSimplex(p::Int, q::Int)
IntervalSimplex()</code></pre><p>A type representing simplices in a simplicial interval (a 1-simplex). An <code>n</code>-simplex in a simplicial interval is determined by two non-negative integers <code>p</code> and <code>q</code> such that <code>p+q-1</code> equals <code>n</code>.</p><p>The first constructor above returns the <code>p+q-1</code>-simplex with <code>p</code> vertices equal to <code>0</code> and <code>q</code> vertices equal to <code>1</code>. The second constructor is a short form for <code>SimplicialInterval(1, 1)</code> and returns the unique non-degenerate <code>1</code>-simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/interval.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.OppositeSimplex" href="#SimplicialSets.OppositeSimplex"><code>SimplicialSets.OppositeSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OppositeSimplex{T&lt;:AbstractSimplex} &lt;: AbstractSimplex</code></pre><p><code>OppositeSimplex(x)</code> is the &#39;opposite&#39; simplex to <code>x</code> in the sense that <code>i</code>-th face operator corresponds to the <code>(n-i)</code>-th face operator for <code>x</code>, and likewise for degeneracy operators.</p><p>The functions <code>*</code>, <code>\</code>, <code>inv</code> and <code>one</code> with argument(s) of type <code>OppositeSimplex</code> work on the underlying simplices.</p><p>Note that the linear extension of <code>OppositeSimplex</code> would not be a chain map from the chain complex of the simplicial set containing the terms <code>x</code> to the opposite simplicial set. For this purpose there is the function <code>opposite</code>.</p><p>See also <a href="#SimplicialSets.opposite"><code>opposite</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SimplicialSets: d, s

julia&gt; x = SymbolicSimplex(:x, 3)
x[0,1,2,3]

julia&gt; y = OppositeSimplex(x)
OppositeSimplex(x[0,1,2,3])

julia&gt; d(y, 1)
OppositeSimplex(x[0,1,3])

julia&gt; s(y, 1)
OppositeSimplex(x[0,1,2,2,3])

julia&gt; z = OppositeSimplex(LoopGroupSimplex(x))
OppositeSimplex(⟨x[0,1,2,3]⟩)

julia&gt; inv(z)
OppositeSimplex(⟨x[0,1,2,3]⁻¹⟩)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/opposite.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimplicialSets.opposite" href="#SimplicialSets.opposite"><code>SimplicialSets.opposite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opposite(x::T) where T &lt;: AbstractSimplex -&gt; OppositeSimplex
opposite(x::T) where {S, T &lt;: OppositeSimplex{S}} -&gt; S
opposite(x::T) where T &lt;: ProductSimplex -&gt; ProductSimplex</code></pre><p>Return an &quot;interpreted version&quot; of the opposite simplex of <code>x</code>:</p><ul><li>If <code>x</code> is already an <code>OppositeSimplex</code>, return the underlying simplex.</li><li>If <code>x</code> is a <code>ProductSimplex</code>, apply <code>opposite</code> to the components and return the corresponding <code>ProductSimplex</code>.</li><li>In all other cases, return <code>OppositeSimplex(x)</code>.</li></ul><p>See also <a href="#SimplicialSets.OppositeSimplex"><code>OppositeSimplex</code></a>, <a href="#SimplicialSets.opposite"><code>opposite(::AbstractTensor)</code></a>, <a href="#SimplicialSets.opposite"><code>opposite(::AbstractLinear)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/opposite.jl#L68-L84">source</a></section><section><div><pre><code class="language-julia hljs">opposite(t::AbstractTensor) -&gt; Tensor</code></pre><p>Apply <code>opposite</code> to the components of <code>t</code> and return their tensor product.</p><p>See also <a href="#SimplicialSets.opposite"><code>opposite(::AbstractSimplex)</code></a>, <a href="#SimplicialSets.opposite"><code>opposite(::AbstractLinear)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/opposite.jl#L89-L97">source</a></section><section><div><pre><code class="language-julia hljs">opposite(a::AbstractLinear{T,R}) -&gt; Linear</code></pre><p>Apply <code>opposite</code> to the terms in <code>a</code> and return a linear combination of them. If the degree of a term <code>x</code> is congruent to <code>1</code> or <code>2</code> mod <code>4</code>, then it is transformed to <code>-opposite(x)</code> and otherwise to <code>opposite(x)</code>.</p><p>Note that this function is <strong>not</strong> the linear extension of <code>opposite(x::AbstractSimplex)</code> or <code>OppositeSimplex</code>. The signs are chosen such that this function is a chain map from the chain complex of the simplicial set containing the terms <code>x</code> to the opposite simplicial set.</p><p>See also <a href="#SimplicialSets.opposite"><code>opposite(::AbstractSimplex)</code></a>, <a href="#SimplicialSets.opposite"><code>opposite(::AbstractTensor)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearCombinations; using LinearCombinations: diff

julia&gt; a = Linear(SymbolicSimplex(:x, 1) =&gt; 2)
2*x[0,1]

julia&gt; b = opposite(a)
-2*OppositeSimplex(x[0,1])

julia&gt; diff(b) == opposite(diff(a))
true

julia&gt; c = Linear(OppositeSimplex(y) =&gt; c for (y, c) in a)
2*OppositeSimplex(x[0,1])

julia&gt; diff(c) == opposite(diff(a))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matthias314/SimplicialSets.jl/blob/38a6d136d22ac98667e3d97ea9fde6963ad24908/src/opposite.jl#L105-L139">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../basic/">Basic functions for simplices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 11 August 2024 09:21">Sunday 11 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
