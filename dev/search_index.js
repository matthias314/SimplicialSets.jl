var documenterSearchIndex = {"docs":
[{"location":"simplices/#Simplices","page":"Simplices","title":"Simplices","text":"","category":"section"},{"location":"simplices/#AbstractSimplex","page":"Simplices","title":"AbstractSimplex","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"AbstractSimplex","category":"page"},{"location":"simplices/#SimplicialSets.AbstractSimplex","page":"Simplices","title":"SimplicialSets.AbstractSimplex","text":"AbstractSimplex <: Any\n\nThis is the supertype of all types representing simplices.\n\n\n\n\n\n","category":"type"},{"location":"simplices/#SymbolicSimplex","page":"Simplices","title":"SymbolicSimplex","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"SymbolicSimplex\nvertices","category":"page"},{"location":"simplices/#SimplicialSets.SymbolicSimplex","page":"Simplices","title":"SimplicialSets.SymbolicSimplex","text":"SymbolicSimplex{L<:Union{Symbol,Char}} <: AbstractSimplex\n\nSymbolicSimplex(label, w::AbstractVector{<:Integer})\nSymbolicSimplex(label, n::Integer)\n\nThis type represents \"symbolic simplices\" that are given by a label and a weakly increasing sequence of non-negative integers enumerating the vertices. Such a simplex is degenerate if any integer is repeated.\n\nThe label can be of type Symbol or Char. The vertex numbers must be between 0 and 31, and the dimension cannot be larger than 24. If an integer n is passed as a second argument to the constructor, then the vertices are 0:n.\n\n\n\n\n\n","category":"type"},{"location":"simplices/#SimplicialSets.vertices","page":"Simplices","title":"SimplicialSets.vertices","text":"vertices(x::SymbolicSimplex) -> Vector{Int}\n\nReturn the vertices of x as a vector.\n\n\n\n\n\n","category":"function"},{"location":"simplices/#ProductSimplex","page":"Simplices","title":"ProductSimplex","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"ProductSimplex\nBase.Tuple(::ProductSimplex)\nlength(x::ProductSimplex)\nSimplicialSets.cat\nSimplicialSets.flatten\nswap\nLinearCombinations.Regroup","category":"page"},{"location":"simplices/#SimplicialSets.ProductSimplex","page":"Simplices","title":"SimplicialSets.ProductSimplex","text":"ProductSimplex{T<:Tuple{Vararg{AbstractSimplex}}} <: AbstractSimplex\n\nProductSimplex{T}{t::Tuple{Vararg{AbstractSimplex}} [; dim::Integer]}\n\nProductSimplex(t::Tuple{Vararg{AbstractSimplex}} [; dim::Integer])\nProductSimplex(xs::AbstractSimplex... [; dim::Integer])\n\nA type representing an element in the product of simplicial sets. Empty products are allowed. The component simplices must all be of the same dimension. They may be given as a tuple or as individual arguments.\n\nIn the case of the empty product, the keyword argument dim is required to determine the dimension of the resulting simplex. Otherwise dim is optional, but if present, it must be correct.\n\nSee also Tuple(x::ProductSimplex).\n\nExamples\n\njulia> x, y = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2)\n(x[0,1,2], y[0,1,2])\n\njulia> z = ProductSimplex(x, y)\n(x[0,1,2],y[0,1,2])\n\njulia> w = ProductSimplex(dim = 2)\n()\n\njulia> dim(w)\n2\n\njulia> ProductSimplex(x, y; dim = 1)\nERROR: dimensions of simplices do not match\n[...]\n\n\n\n\n\n","category":"type"},{"location":"simplices/#Core.Tuple-Tuple{ProductSimplex}","page":"Simplices","title":"Core.Tuple","text":"Tuple(x::ProductSimplex{T}) where T <: Tuple{Vararg{AbstractSimplex}} -> T\n\nReturn the tuple of component simplices of x.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.length-Tuple{ProductSimplex}","page":"Simplices","title":"Base.length","text":"length(x::ProductSimplex) -> Int\n\nReturn the number of components (or factors) of x.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#LinearCombinations.cat","page":"Simplices","title":"LinearCombinations.cat","text":"SimplicialSets.cat(x::ProductSimplex...) -> ProductSimplex\n\nReturn the product simplex that is the concatenation of the simplices given as arguments.\n\nThis function is linear. Also note that it is overloaded from the package LinearCombinations, not from Base. If one wants to use the short form cat, then one needs to import the function via using or import.\n\nSee also flatten.\n\nExample\n\njulia> using SimplicialSets: cat   # or: using LinearCombinations: cat\n\njulia> u = ProductSimplex(SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2))\n(x[0,1],y[0,1])\n\njulia> v = ProductSimplex(SymbolicSimplex(:z, 2), SymbolicSimplex(:w, 2))\n(z[0,1],w[0,1])\n\njulia> cat(u, v)\n(x[0,1],y[0,1],z[0,1],w[0,1])\n\n\n\n\n\n","category":"function"},{"location":"simplices/#LinearCombinations.flatten","page":"Simplices","title":"LinearCombinations.flatten","text":"SimplicialSets.flatten(x::ProductSimplex) -> ProductSimplex\n\nReturn the product simplex that is obtained by recursively flattening all product simplices appearing within x.\n\nThis function is linear. Also note that it is overloaded from the package LinearCombinations.\n\nSee also LinearCombinations.Regroup, SimplicialSets.cat.\n\nExamples\n\njulia> using SimplicialSets: flatten   # or: using LinearCombinations: flatten\n\njulia> u = ProductSimplex(SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2))\n(x[0,1],y[0,1])\n\njulia> v = ProductSimplex(SymbolicSimplex(:z, 2), SymbolicSimplex(:w, 2))\n(z[0,1],w[0,1])\n\njulia> flatten(ProductSimplex(u, v))\n(x[0,1],y[0,1],z[0,1],w[0,1])\n\njulia> flatten(ProductSimplex(ProductSimplex(u, v), u))\n(x[0,1],y[0,1],z[0,1],w[0,1],x[0,1],y[0,1])\n\n\n\n\n\n","category":"function"},{"location":"simplices/#LinearCombinations.swap","page":"Simplices","title":"LinearCombinations.swap","text":"swap(z::ProductSimplex{Tuple{S,T}}) where {S <: AbstractSimplex, T <: AbstractSimplex} -> ProductSimplex{Tuple{T,S}}\n\nSwap the two components of the ProductSimplex z and return the resulting ProductSimplex.\n\nThis function is linear. Also note that it is overloaded from the package LinearCombinations.\n\nSee also LinearCombinations.Regroup.\n\n\n\n\n\n","category":"constant"},{"location":"simplices/#LinearCombinations.Regroup","page":"Simplices","title":"LinearCombinations.Regroup","text":"(rg::LinearCombinations.Regroup)(z::ProductSimplex) -> ProductSimplex\n\nApply the Regroup element rg to z and return the result. This allows to permute and restructure the components of a product simplex in an arbitrary way (without dropping any component).\n\nThis functions is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for @linear.\n\nSee LinearCombinations.@linear, LinearCombinations.regroup, swap, flatten.\n\nExample\n\njulia> using LinearCombinations\n\njulia> rg = regroup(:( ((1, 2), 3) ), :( (2, (3, 1))  ))\nRegroup{((1, 2), 3),(2, (3, 1))}\n\njulia> x, y, z = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2), SymbolicSimplex(:z, 2)\n(x[0,1,2], y[0,1,2], z[0,1,2])\n\njulia> w = ProductSimplex(ProductSimplex(x, y), z)\n((x[0,1,2],y[0,1,2]),z[0,1,2])\n\njulia> rg(w)\n(y[0,1,2],(z[0,1,2],x[0,1,2]))\n\n\n\n\n\n","category":"type"},{"location":"simplices/#BarSimplex","page":"Simplices","title":"BarSimplex","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"BarSimplex\nlength(::BarSimplex)\none(::BarSimplex)\nisone(::BarSimplex)\n*(::BarSimplex{T}, ::BarSimplex{T}...) where T\ninv(::BarSimplex)\n/(::BarSimplex{T}, ::BarSimplex{T}) where T\n^(::BarSimplex, ::Integer)","category":"page"},{"location":"simplices/#SimplicialSets.BarSimplex","page":"Simplices","title":"SimplicialSets.BarSimplex","text":"BarSimplex{T} <: AbstractSimplex\n\nBarSimplex(iter; op::Union{typeof(*),typeof(+)} = *) -> BarSimplex\n\nA type representing simplices in a simplicial bar construction. If T is a subtype of AbstractSimplex, then it is assumed to be a simplicial group; otherwise T is assumed to be a multiplicative discrete group.\n\nThe constructor accepts an iterator over the components of the bar simplex. The optional keyword op indicates whether the group is multiplicative (default) or additive.\n\nIterating over a BarSimplex means iterating over its components.\n\nSee also AddToMul.\n\nExamples\n\njulia> using SimplicialSets: d, s\n\njulia> b = BarSimplex([Lattice(1, 2), Lattice(3, 4)]; op = +)\n[(1, 2),(3, 4)]\n\njulia> d(b, 0)\n[(3, 4)]\n\njulia> d(b, 1)\n[(4, 6)]\n\njulia> s(b, 1)\n[(1, 2),(0, 0),(3, 4)]\n\njulia> collect(b)\n2-element Vector{AddToMul{Lattice{2}}}:\n (1, 2)\n (3, 4)\n\njulia> b1 = BarSimplex([Lattice(1, 2)]; op = +)\n[(1, 2)]\n\njulia> b0 = BarSimplex(Lattice{2}[]; op = +)\n[]\n\njulia> c = BarSimplex([b0, b1])\n[[],[(1, 2)]]\n\njulia> s(c, 1)\n[[],[(0, 0)],[(0, 0),(1, 2)]]\n\n\n\n\n\n","category":"type"},{"location":"simplices/#Base.length-Tuple{BarSimplex}","page":"Simplices","title":"Base.length","text":"length(x::BarSimplex) -> Int\n\nThe length of a BarSimplex is the number of its components.\n\nSee also Tuple(::BarSimplex).\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.one-Tuple{BarSimplex}","page":"Simplices","title":"Base.one","text":"one(x::BarSimplex{T}, n::Integer = dim(x)) where T -> BarSimplex{T}\n\nReturn the identity element in the group of n-simplices in the simplicial bar construction containing x. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.isone-Tuple{BarSimplex}","page":"Simplices","title":"Base.isone","text":"isone(x::BarSimplex{T}) where T -> Bool\n\nReturn true if x is the identity element in the group of bar simplices of dimension equal to the dimension of x. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.:*-Union{Tuple{T}, Tuple{BarSimplex{T}, Vararg{BarSimplex{T}}}} where T","page":"Simplices","title":"Base.:*","text":"*(x::BarSimplex{T}...) where T -> BarSimplex{T}\n\nReturn the product of the given simplices, which must all have the same dimension. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.inv-Tuple{BarSimplex}","page":"Simplices","title":"Base.inv","text":"inv(x::BarSimplex{T}) where T -> BarSimplex{T}\n\nReturn the inverse element of x in the group of n-simplices in the simplicial bar construction containing that simplex. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.:/-Union{Tuple{T}, Tuple{BarSimplex{T}, BarSimplex{T}}} where T","page":"Simplices","title":"Base.:/","text":"/(x::BarSimplex{T}, y::BarSimplex{T}) where T -> BarSimplex{T}\n\nReturn the quotient of the x by y in the commutative group of n-simplices in the simplicial bar construction, where n is the common dimension of x and y. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.:^-Tuple{BarSimplex, Integer}","page":"Simplices","title":"Base.:^","text":"^(x::BarSimplex{T}, n::Integer) where T -> BarSimplex{T}\n\nReturn the n-th power of the simplex x. Here T is assumed to be a commutative (simplicial) group.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#LoopGroupSimplex","page":"Simplices","title":"LoopGroupSimplex","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"SimplicialSets.LoopGroupGenerator\nLoopGroupSimplex\nlength(::LoopGroupSimplex)\nisone(::LoopGroupSimplex)\ninv(::LoopGroupSimplex)\nSimplicialSets.mul!\n*(::LoopGroupSimplex{T}, ::LoopGroupSimplex{T}...) where T <: AbstractSimplex","category":"page"},{"location":"simplices/#SimplicialSets.LoopGroupGenerator","page":"Simplices","title":"SimplicialSets.LoopGroupGenerator","text":"SimplicalSets.LoopGroupGenerator{T <: AbstractSimplex}\n\nThis type represents multiplicative generators of the loop group of the simplicial set with simplices of type T. An element of type LoopGroupGenerator{T} is a pair of a simplex gen of type T and Bool value inv. The latter indicates whether this element represents generator corresponding to gen (inv == false) or its inverse (inv == true).\n\nExamples\n\njulia> using SimplicialSets: LoopGroupGenerator\n\njulia> x = SymbolicSimplex(:x, 2)\nx[0,1,2]\n\njulia> LoopGroupGenerator(x, false)\nx[0,1,2]\n\njulia> LoopGroupGenerator(x, true)\nx[0,1,2]⁻¹\n\n\n\n\n\n","category":"type"},{"location":"simplices/#SimplicialSets.LoopGroupSimplex","page":"Simplices","title":"SimplicialSets.LoopGroupSimplex","text":"LoopGroupSimplex{T<:AbstractSimplex} <: AbstractSimplex\n\nLoopGroupSimplex(x::T) where T <: AbstractSimplex\n\nThis type represents simplices in the Kan loop groups of the simplicial set with elements of type T. The latter simplicial set is assume to be reduced, meaning that it contains a single simplex of dimension 0.\n\nThe constructor returns the simplex in the loop group determined by the simplex x, which must be of strictly positive dimension.\n\nIterating over a LoopGroupSimplex{T} yields its components, which are of type LoopGroupGenerator{T}.\n\nSee also SimplicialSets.LoopGroupGenerator.\n\nExamples\n\njulia> using SimplicialSets: s, d\n\njulia> x = SymbolicSimplex(:x, 2); y = LoopGroupSimplex(x)\n⟨x[0,1,2]⟩\n\njulia> d(y, 1), d(y, 0)\n(⟨x[0,1]⟩, ⟨x[1,2]⁻¹,x[0,2]⟩)\n\njulia> LoopGroupSimplex(s(x, 0))\n⟨⟩\n\n\n\n\n\n","category":"type"},{"location":"simplices/#Base.length-Tuple{LoopGroupSimplex}","page":"Simplices","title":"Base.length","text":"length(x::LoopGroupSimplex) -> Int\n\nThe length of a LoopGroupSimplex is the number of its components.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.isone-Tuple{LoopGroupSimplex}","page":"Simplices","title":"Base.isone","text":"isone(x::LoopGroupSimplex{T}) where T -> Bool\n\nReturn true if x is the identity element in the loop group simplices of dimension equal to the dimension of x.\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Base.inv-Tuple{LoopGroupSimplex}","page":"Simplices","title":"Base.inv","text":"Base.inv(g::L) where L <: LoopGroupSimplex -> L\n\nReturn the inverse of the simplex g in the loop group.\n\nExample\n\njulia> g, h = LoopGroupSimplex(SymbolicSimplex(:x, 2)), LoopGroupSimplex(SymbolicSimplex(:y, 2))\n(⟨x[0,1,2]⟩, ⟨y[0,1,2]⟩)\n\njulia> inv(g*h)\n⟨y[0,1,2]⁻¹,x[0,1,2]⁻¹⟩\n\n\n\n\n\n","category":"method"},{"location":"simplices/#SimplicialSets.mul!","page":"Simplices","title":"SimplicialSets.mul!","text":"SimplicialSets.mul!(g::L, hs::L...) where L <: LoopGroupSimplex\n\nMultiply the simplex g from the right by the simplices given as other arguments in-place and return g.\n\nExample\n\njulia> g = LoopGroupSimplex(SymbolicSimplex(:x, 2))\n⟨x[0,1,2]⟩\n\njulia> h = LoopGroupSimplex(SymbolicSimplex(:y, 2))\n⟨y[0,1,2]⟩\n\njulia> SimplicialSets.mul!(g, h)\n⟨x[0,1,2],y[0,1,2]⟩\n\njulia> g\n⟨x[0,1,2],y[0,1,2]⟩\n\n\n\n\n\n","category":"function"},{"location":"simplices/#Base.:*-Union{Tuple{T}, Tuple{LoopGroupSimplex{T}, Vararg{LoopGroupSimplex{T}}}} where T<:AbstractSimplex","page":"Simplices","title":"Base.:*","text":"*(g::L...) where L <: LoopGroupSimplex -> L\n\nMultiply the given simplices in the loop group. At least one simplex must be given, and they must all have the same dimension.\n\nSee also SimplicialSets.mul!.\n\nExample\n\njulia> g = LoopGroupSimplex(SymbolicSimplex(:x, 2))\n⟨x[0,1,2]⟩\n\njulia> h = LoopGroupSimplex(SymbolicSimplex(:y, 2))\n⟨y[0,1,2]⟩\n\njulia> g*h\n⟨x[0,1,2],y[0,1,2]⟩\n\n\n\n\n\n","category":"method"},{"location":"simplices/#Other-simplices","page":"Simplices","title":"Other simplices","text":"","category":"section"},{"location":"simplices/","page":"Simplices","title":"Simplices","text":"IntervalSimplex\nOppositeSimplex\nopposite","category":"page"},{"location":"simplices/#SimplicialSets.IntervalSimplex","page":"Simplices","title":"SimplicialSets.IntervalSimplex","text":"IntervalSimplex <: AbstractSimplex\n\nIntervalSimplex(p::Int, q::Int)\nIntervalSimplex()\n\nA type representing simplices in a simplicial interval (a 1-simplex). An n-simplex in a simplicial interval is determined by two non-negative integers p and q such that p+q-1 equals n.\n\nThe first constructor above returns the p+q-1-simplex with p vertices equal to 0 and q vertices equal to 1. The second constructor is a short form for SimplicialInterval(1, 1) and returns the unique non-degenerate 1-simplex.\n\n\n\n\n\n","category":"type"},{"location":"simplices/#SimplicialSets.OppositeSimplex","page":"Simplices","title":"SimplicialSets.OppositeSimplex","text":"OppositeSimplex{T<:AbstractSimplex} <: AbstractSimplex\n\nOppositeSimplex(x) is the 'opposite' simplex to x in the sense that i-th face operator corresponds to the (n-i)-th face operator for x, and likewise for degeneracy operators.\n\nThe functions *, \\, inv and one with argument(s) of type OppositeSimplex work on the underlying simplices.\n\nNote that the linear extension of OppositeSimplex would not be a chain map from the chain complex of the simplicial set containing the terms x to the opposite simplicial set. For this purpose there is the function opposite.\n\nSee also opposite.\n\nExamples\n\njulia> using SimplicialSets: d, s\n\njulia> x = SymbolicSimplex(:x, 3)\nx[0,1,2,3]\n\njulia> y = OppositeSimplex(x)\nOppositeSimplex(x[0,1,2,3])\n\njulia> d(y, 1)\nOppositeSimplex(x[0,1,3])\n\njulia> s(y, 1)\nOppositeSimplex(x[0,1,2,2,3])\n\njulia> z = OppositeSimplex(LoopGroupSimplex(x))\nOppositeSimplex(⟨x[0,1,2,3]⟩)\n\njulia> inv(z)\nOppositeSimplex(⟨x[0,1,2,3]⁻¹⟩)\n\n\n\n\n\n","category":"type"},{"location":"simplices/#SimplicialSets.opposite","page":"Simplices","title":"SimplicialSets.opposite","text":"opposite(x::T) where T <: AbstractSimplex -> OppositeSimplex\nopposite(x::T) where {S, T <: OppositeSimplex{S}} -> S\nopposite(x::T) where T <: ProductSimplex -> ProductSimplex\n\nReturn an \"interpreted version\" of the opposite simplex of x:\n\nIf x is already an OppositeSimplex, return the underlying simplex.\nIf x is a ProductSimplex, apply opposite to the components and return the corresponding ProductSimplex.\nIn all other cases, return OppositeSimplex(x).\n\nSee also OppositeSimplex, opposite(::AbstractTensor), opposite(::AbstractLinear).\n\n\n\n\n\nopposite(t::AbstractTensor) -> Tensor\n\nApply opposite to the components of t and return their tensor product.\n\nSee also opposite(::AbstractSimplex), opposite(::AbstractLinear).\n\n\n\n\n\nopposite(a::AbstractLinear{T,R}) -> Linear\n\nApply opposite to the terms in a and return a linear combination of them. If the degree of a term x is congruent to 1 or 2 mod 4, then it is transformed to -opposite(x) and otherwise to opposite(x).\n\nNote that this function is not the linear extension of opposite(x::AbstractSimplex) or OppositeSimplex. The signs are chosen such that this function is a chain map from the chain complex of the simplicial set containing the terms x to the opposite simplicial set.\n\nSee also opposite(::AbstractSimplex), opposite(::AbstractTensor).\n\nExamples\n\njulia> using LinearCombinations; using LinearCombinations: diff\n\njulia> a = Linear(SymbolicSimplex(:x, 1) => 2)\n2*x[0,1]\n\njulia> b = opposite(a)\n-2*OppositeSimplex(x[0,1])\n\njulia> diff(b) == opposite(diff(a))\ntrue\n\njulia> c = Linear(OppositeSimplex(y) => c for (y, c) in a)\n2*OppositeSimplex(x[0,1])\n\njulia> diff(c) == opposite(diff(a))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ez/#Eilenberg–Zilber-maps","page":"Eilenberg–Zilber maps","title":"Eilenberg–Zilber maps","text":"","category":"section"},{"location":"ez/#Shuffle-map","page":"Eilenberg–Zilber maps","title":"Shuffle map","text":"","category":"section"},{"location":"ez/","page":"Eilenberg–Zilber maps","title":"Eilenberg–Zilber maps","text":"ez","category":"page"},{"location":"ez/#SimplicialSets.ez","page":"Eilenberg–Zilber maps","title":"SimplicialSets.ez","text":"ez(x::AbstractSimplex...) -> ProductSimplex\n\nez(AbstractTensor{T}) where T <: Tuple{Vararg{AbstractSimplex}} -> ProductSimplex{T}\n\nReturn the image of the given simplices under the Eilenberg–Zilber or shuffle map. The first version is multilinear in the simplices and the second one linear in the tensor argument. Any number of simplices is allowed, including zero.\n\nThis function supports the keyword arguments coefftype, addto, coeff, sizehint and is_filtered as described for the macro @linear.\n\nSee also aw, shih, LinearCombinations.@linear.\n\nExamples\n\njulia> x, y = SymbolicSimplex(:x, 1), SymbolicSimplex(:y, 2)\n(x[0,1], y[0,1,2])\n\njulia> a = ez(x, y)\n(x[0,1,1,1],y[0,0,1,2])-(x[0,0,1,1],y[0,1,1,2])+(x[0,0,0,1],y[0,1,2,2])\n\njulia> ez(Tensor(x, y); addto = a, coeff = -1)\n0\n\njulia> z = SymbolicSimplex(:z, 0)\nz[0]\n\njulia> ez(x, y, z)\n-(x[0,0,1,1],y[0,1,1,2],z[0,0,0,0])+(x[0,0,0,1],y[0,1,2,2],z[0,0,0,0])+(x[0,1,1,1],y[0,0,1,2],z[0,0,0,0])\n\njulia> ez(x, y, z) == ez(ez(x, y), z)\nfalse\n\njulia> ez(x)\n(x[0,1])\n\njulia> ez(Tensor())\n()\n\n\n\n\n\n","category":"function"},{"location":"ez/#Alexander–Whitney-map","page":"Eilenberg–Zilber maps","title":"Alexander–Whitney map","text":"","category":"section"},{"location":"ez/","page":"Eilenberg–Zilber maps","title":"Eilenberg–Zilber maps","text":"aw","category":"page"},{"location":"ez/#SimplicialSets.aw","page":"Eilenberg–Zilber maps","title":"SimplicialSets.aw","text":"aw(x::ProductSimplex{T}) where T <: Tuple{Vararg{AbstractSimplex}} -> Linear{Tensor{T}}\n\nReturn the image of the given product simplex under the Alexander-Whitney map. The product simplex may have any number of components, including zero. The number of components in the resulting tensor product is the same as the number of components of the product simplex.\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for the macro @linear.\n\nSee also coprod, ez, shih, LinearCombinations.@linear.\n\nExamples\n\njulia> x, y = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2)\n(x[0,1,2], y[0,1,2])\n\njulia> aw(ProductSimplex(x, y))\nx[0]⊗y[0,1,2]+x[0,1,2]⊗y[2]+x[0,1]⊗y[1,2]\n\njulia> z = SymbolicSimplex(:z, 2); aw(ProductSimplex(x, y, z))\nx[0,1]⊗y[1]⊗z[1,2]+x[0,1,2]⊗y[2]⊗z[2]+x[0,1]⊗y[1,2]⊗z[2]+x[0]⊗y[0]⊗z[0,1,2]+x[0]⊗y[0,1]⊗z[1,2]+x[0]⊗y[0,1,2]⊗z[2]\n\njulia> aw(ProductSimplex(x))\nx[0,1,2]\n\njulia> aw(ProductSimplex(; dim = 0))\n()\n\n\n\n\n\n","category":"function"},{"location":"ez/#Homotopies","page":"Eilenberg–Zilber maps","title":"Homotopies","text":"","category":"section"},{"location":"ez/","page":"Eilenberg–Zilber maps","title":"Eilenberg–Zilber maps","text":"shih\nshih_opp","category":"page"},{"location":"ez/#SimplicialSets.shih","page":"Eilenberg–Zilber maps","title":"SimplicialSets.shih","text":"shih(z::ProductSimplex{T}) where T <: Tuple{AbstractSimplex,AbstractSimplex} -> Linear{T}\nshih_eml(z::ProductSimplex{T}) where T <: Tuple{AbstractSimplex,AbstractSimplex} -> Linear{T}\n\nReturn the image of the product simplex z under the Eilenberg–MacLane homotopy (which is sometimes called the Shih map).\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff, sizehint and is_filtered as described for the macro @linear.\n\nSee also aw, ez, shih_opp, LinearCombinations.@linear.\n\nExamples\n\njulia> x, y = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2); z = ProductSimplex(x, y)\n(x[0,1,2],y[0,1,2])\n\njulia> shih(z)\n-(x[0,1,1,2],y[0,1,2,2])+(x[0,0,1,1],y[0,1,1,2])-(x[0,0,0,1],y[0,1,2,2])+(x[0,0,1,2],y[0,2,2,2])\n\njulia> shih(ez(x, y))\n0\n\njulia> shih(ez(x, y)), aw(shih(z)), shih(shih(z))\n(0, 0, 0)\n\n\n\n\n\n","category":"function"},{"location":"ez/#SimplicialSets.shih_opp","page":"Eilenberg–Zilber maps","title":"SimplicialSets.shih_opp","text":"shih_opp(z::ProductSimplex{T}) where T <: Tuple{AbstractSimplex,AbstractSimplex} -> Linear{T}\n\nReturn the image of the product simplex z under the opposite Eilenberg–MacLane homotopy (which is sometimes called the opposite Shih map).\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff, sizehint and is_filtered as described for the macro @linear.\n\nSee also aw, ez, shih, opposite, swap, LinearCombinations.@linear.\n\nExample\n\njulia> x, y = SymbolicSimplex(:x, 2), SymbolicSimplex(:y, 2)\n(x[0,1,2], y[0,1,2])\n\njulia> a = Linear(ProductSimplex(x, y) => 1)   # we use `Linear` to get the correct sign from `opposite` below\n(x[0,1,2],y[0,1,2])\n\njulia> shih_opp(a)\n-(x[0,1,1,2],y[1,1,2,2])-(x[0,0,0,2],y[0,1,2,2])+(x[0,0,1,2],y[0,1,1,2])+(x[0,0,1,2],y[1,2,2,2])\n\njulia> shih(a)\n-(x[0,0,0,1],y[0,1,2,2])+(x[0,0,1,2],y[0,2,2,2])-(x[0,1,1,2],y[0,1,2,2])+(x[0,0,1,1],y[0,1,1,2])\n\njulia> shih_opp(opposite(swap(a))) == opposite(swap(shih(a)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"basic/#Basic-functions-for-simplices","page":"Basic functions for simplices","title":"Basic functions for simplices","text":"","category":"section"},{"location":"basic/","page":"Basic functions for simplices","title":"Basic functions for simplices","text":"dim\ndeg(::AbstractSimplex)\nSimplicialSets.d\nSimplicialSets.s\nisdegenerate(::AbstractSimplex)\nisdegenerate(::AbstractSimplex, ::Integer)\nisdegenerate(::AbstractSimplex, ::Integer, ::Integer)\nLinearCombinations.linear_filter(::AbstractSimplex)\nLinearCombinations.diff(::AbstractSimplex)\ndiag\nLinearCombinations.coprod","category":"page"},{"location":"basic/#SimplicialSets.dim","page":"Basic functions for simplices","title":"SimplicialSets.dim","text":"dim(x::AbstractSimplex) -> Int\n\nReturn the dimension of the simplex x.\n\nSee also [deg].\n\n\n\n\n\n","category":"function"},{"location":"basic/#LinearCombinations.deg-Tuple{AbstractSimplex}","page":"Basic functions for simplices","title":"LinearCombinations.deg","text":"deg(x::AbstractSimplex) -> Int\n\nReturn the degree of x, which is defined as its dimension.\n\nSee also dim.\n\n\n\n\n\n","category":"method"},{"location":"basic/#SimplicialSets.d","page":"Basic functions for simplices","title":"SimplicialSets.d","text":"SimplicialSets.d(x::T, k) where T <: AbstractSimplex -> T\nSimplicialSets.d(x::T, kv::AbstractVector{<:Integer}) where T <: AbstractSimplex -> T\n\nIn the first form, return the k-th facet of x. In the second form, apply d repeatedly to x, starting with the last element of kv.\n\nSee also SimplicialSets.s.\n\nExamples\n\njulia> using SimplicialSets: d\n\njulia> x = SymbolicSimplex(:x, 3)\nx[0,1,2,3]\n\njulia> d(x, 1)\nx[0,2,3]\n\njulia> d(x, [1, 3])\nx[0,2]\n\n\n\n\n\n","category":"function"},{"location":"basic/#SimplicialSets.s","page":"Basic functions for simplices","title":"SimplicialSets.s","text":"SimplicialSets.s(x::T, k) where T <: AbstractSimplex -> T\nSimplicialSets.s(x::T, kv::AbstractVector{<:Integer}) where T <: AbstractSimplex -> T\n\nIn the first form, return the k-th degeneracy of x. In the second form, apply d repeatedly to x, starting with the first element of kv.\n\nSee also SimplicialSets.d.\n\nExamples\n\njulia> using SimplicialSets: s\n\njulia> x = SymbolicSimplex(:x, 3)\nx[0,1,2,3]\n\njulia> s(x, 1)\nx[0,1,1,2,3]\n\njulia> s(x, [1, 3])\nx[0,1,1,2,2,3]\n\n\n\n\n\n","category":"function"},{"location":"basic/#SimplicialSets.isdegenerate-Tuple{AbstractSimplex}","page":"Basic functions for simplices","title":"SimplicialSets.isdegenerate","text":"isdegenerate(x::AbstractSimplex) -> Bool\n\nReturn true if x is degenerate and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"basic/#SimplicialSets.isdegenerate-Tuple{AbstractSimplex, Integer}","page":"Basic functions for simplices","title":"SimplicialSets.isdegenerate","text":"isdegenerate(x::AbstractSimplex, k::Integer) -> Bool\n\nReturn true if x is degenerate at position k and false otherwise. The index k must be between 0 and dim(x)-1.\n\nA simplex x of positive dimension is degenerate at position k if x == s(d(x, k), k).\n\n\n\n\n\n","category":"method"},{"location":"basic/#SimplicialSets.isdegenerate-Tuple{AbstractSimplex, Integer, Integer}","page":"Basic functions for simplices","title":"SimplicialSets.isdegenerate","text":"isdegenerate(x::AbstractSimplex, k0::Integer, k1::Integer) -> Bool\n\nReturn true if x is degenerate on the interval k0:k1 and false otherwise. The indices must satisfy 0 <= k0 <= k1 <= dim(x).\n\nA simplex is degenerate on the interval k0:k1 if it degenerate at some position k between k0 and k1-1.\n\n\n\n\n\n","category":"method"},{"location":"basic/#LinearCombinations.linear_filter-Tuple{AbstractSimplex}","page":"Basic functions for simplices","title":"LinearCombinations.linear_filter","text":"LinearCombinations.linear_filter(x::AbstractSimplex) -> Bool\n\nReturn true if x is non-degenerate and false otherwise. The effect of this is that linear combinations of simplices represent elements of the normalized chain complex of the corresponding simplicial set.\n\nSee also LinearCombinations.linear_filter.\n\nExample\n\njulia> using LinearCombinations; using SimplicialSets: s\n\njulia> x = SymbolicSimplex(:x, 2)\nx[0,1,2]\n\njulia> Linear(s(x, 1) => 1)\n0\n\n\n\n\n\n","category":"method"},{"location":"basic/#LinearCombinations.diff-Tuple{AbstractSimplex}","page":"Basic functions for simplices","title":"LinearCombinations.diff","text":"diff(x::T) where T <: AbstractSimplex -> Linear{T}\n\nReturn the differential or boundary of x as a linear combination. By default, the coefficients are of type Int.\n\nThis functions is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for @linear.\n\nNote that because of a name clash with Base.diff, this function must be explicitly imported.\n\nSee also LinearCombinations.@linear.\n\nExamples\n\njulia> using LinearCombinations; using LinearCombinations: diff\n\njulia> x = SymbolicSimplex(:x, 2)\nx[0,1,2]\n\njulia> a = diff(x)\nx[1,2]-x[0,2]+x[0,1]\n\njulia> b = zero(a); diff(x; addto = b, coeff = 2)\n2*x[1,2]-2*x[0,2]+2*x[0,1]\n\njulia> b\n2*x[1,2]-2*x[0,2]+2*x[0,1]\n\n\n\n\n\n","category":"method"},{"location":"basic/#SimplicialSets.diag","page":"Basic functions for simplices","title":"SimplicialSets.diag","text":"diag(x::T) where T <: AbstractSimplex -> ProductSimplex{Tuple{T,T}}\n\nReturn the image of x under the diagonal map from the simplicial set containing x to the Cartesian product with itself.\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff, sizehint and is_filtered as described for the macro @linear.\n\nSee also coprod, LinearCombinations.@linear.\n\n\n\n\n\n","category":"function"},{"location":"basic/#LinearCombinations.coprod","page":"Basic functions for simplices","title":"LinearCombinations.coprod","text":"coprod(x::T) where T <: AbstractSimplex -> Linear{Tensor{Tuple{T,T}}}\n\nReturn the image of the simplex x under coproduct (or diagonal map) of the normalized chain complex containing x.\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for the macro @linear.\n\nSee also aw, diag, LinearCombinations.@linear.\n\nExamples\n\njulia> x = SymbolicSimplex(:x, 2)\nx[0,1,2]\n\njulia> coprod(x)\nx[0]⊗x[0,1,2]+x[0,1,2]⊗x[2]+x[0,1]⊗x[1,2]\n\njulia> coprod(x) == aw(diag(x))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"surjection/#Surjection-operad-and-interval-cuts","page":"Surjection operad and interval cuts","title":"Surjection operad and interval cuts","text":"","category":"section"},{"location":"surjection/","page":"Surjection operad and interval cuts","title":"Surjection operad and interval cuts","text":"Surjection\narity\ndeg(::Surjection)\nSimplicialSets.is_surjection\nisdegenerate(::Surjection)\nLinearCombinations.linear_filter(::Surjection)\nLinearCombinations.diff(::Surjection)","category":"page"},{"location":"surjection/#SimplicialSets.Surjection","page":"Surjection operad and interval cuts","title":"SimplicialSets.Surjection","text":"Surjection{K}\n\nSurjection{K}(u [; check = true]) where K\nSurjection(u)\n\n(surj::Surjection)(x::T) where T <: AbstractSimplex -> Linear{T}\n\nThe type Surjection{K} represents elements of arity K in the surjection operad.\n\nThe first constructor return the surjection given by u TODO. If the optional keyword argument check is set to false, then it is not checked that u is indeed a surjection. The second constructor is equivalent to the first with K set to maximum(u; init = 0).\n\nWhen a Surjection is applied to a simplex, the result is the corresponding interval cut operation. This evaluation is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for the macro @linear.\n\nSee also arity, deg(::Surjection), diff(::Surjection), SimplicialSets.is_surjection, LinearCombinations.linear_filter(::Surjection), LinearCombinations.@linear.\n\nExamples\n\nSurjection operad\n\njulia> Surjection([1, 2, 3, 1])\nSurjection{3}([1, 2, 3, 1])\n\njulia> Surjection(Int[])\nSurjection{0}(Int64[])\n\nInterval cuts\n\njulia> using LinearCombinations: diff, deg\n\njulia> surj = Surjection([1, 2, 1])\nSurjection{2}([1, 2, 1])\n\njulia> x = SymbolicSimplex(:x, 2)\nx[0,1,2]\n\njulia> surj(x)\n-x[0,1,2]⊗x[0,1]-x[0,1,2]⊗x[1,2]+x[0,2]⊗x[0,1,2]\n\njulia> diff(surj(x)) == diff(surj)(x) + (-1)^deg(surj) * surj(diff(x))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"surjection/#SimplicialSets.arity","page":"Surjection operad and interval cuts","title":"SimplicialSets.arity","text":"arity(surj::Surjection{K}) where K -> K\n\nReturn the arity of the surjection surj.\n\n\n\n\n\n","category":"function"},{"location":"surjection/#LinearCombinations.deg-Tuple{Surjection}","page":"Surjection operad and interval cuts","title":"LinearCombinations.deg","text":"deg(surj::Surjection) -> Int\n\nReturn the degree of surj, which is the number of repetitions in the sequence of values.\n\n\n\n\n\n","category":"method"},{"location":"surjection/#SimplicialSets.is_surjection","page":"Surjection operad and interval cuts","title":"SimplicialSets.is_surjection","text":"SimplicialSets.is_surjection(k::Integer, u::AbstractVector{<:Integer}) -> Bool\n\nReturn true if u defines a surjection of arity k, that is, if it contains all values between 1 and k and no other values. In this case the call Surjection{k}(u) would return successfully.\n\nSee also Surjection, arity.\n\n\n\n\n\n","category":"function"},{"location":"surjection/#SimplicialSets.isdegenerate-Tuple{Surjection}","page":"Surjection operad and interval cuts","title":"SimplicialSets.isdegenerate","text":"isdegenerate(surj::Surjection) -> Bool\n\nA surjection is degenerate if two adjacent values are equal.\n\nExamples\n\njulia> isdegenerate(Surjection([1, 2, 1]))\nfalse\n\njulia> isdegenerate(Surjection([1, 1, 2]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"surjection/#LinearCombinations.linear_filter-Tuple{Surjection}","page":"Surjection operad and interval cuts","title":"LinearCombinations.linear_filter","text":"LinearCombinations.linear_filter(surj::Surjection) -> Bool\n\nReturn true if surj is not degenerate.\n\nSee also LinearCombinations.linear_filter.\n\n\n\n\n\n","category":"method"},{"location":"surjection/#LinearCombinations.diff-Tuple{Surjection}","page":"Surjection operad and interval cuts","title":"LinearCombinations.diff","text":"diff(surj::Surjection{K}) where K -> Linear{Surjection{K}}\n\nReturn the differential (or boundary) of surj in the surjection operad.\n\nThis function is linear and supports the keyword arguments coefftype, addto, coeff and is_filtered as described for the macro @linear.\n\nSee also LinearCombinations.@linear.\n\nExample\n\njulia> using LinearCombinations: diff\n\njulia> surj = Surjection([1, 2, 1, 3, 1])\nSurjection{3}([1, 2, 1, 3, 1])\n\njulia> diff(surj)\nSurjection{3}([1, 2, 1, 3])-Surjection{3}([1, 2, 3, 1])+Surjection{3}([2, 1, 3, 1])\n\n\n\n\n\n","category":"method"},{"location":"","page":"Overview","title":"Overview","text":"DocTestSetup = doctestsetup","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"SimplicialSets","category":"page"},{"location":"#SimplicialSets","page":"Overview","title":"SimplicialSets","text":"SimplicialSets\n\nThis package provides types and functions to work with simplicial sets. Various kinds of simplicial sets are supported, including symbolic simplices, products, bar constructions and Kan loop groups. The Eilenberg–Zilber maps and interval cut operations are also implemented.\n\nThe package uses LinearCombinations.jl to represent formal linear combinations of simplices and other objects. By default, coefficients are of type Int.\n\n\n\n\n\n","category":"module"},{"location":"helpers/#Helper-types-for-groups","page":"Helper types for groups","title":"Helper types for groups","text":"","category":"section"},{"location":"helpers/","page":"Helper types for groups","title":"Helper types for groups","text":"AddToMul\nLattice\nTuple(::Lattice)","category":"page"},{"location":"helpers/#SimplicialSets.AddToMul","page":"Helper types for groups","title":"SimplicialSets.AddToMul","text":"AddToMul{T}\n\nA wrapper to turn an additive group structure defined for the type T into a multiplicative structure.\n\nExamples\n\njulia> x, y = AddToMul(2), AddToMul(3)\n(2, 3)\n\njulia> x*y\n5\n\njulia> x^2\n4\n\njulia> inv(x)\n-2\n\njulia> x/y\n-1\n\njulia> one(x)\n0\n\n\n\n\n\n","category":"type"},{"location":"helpers/#SimplicialSets.Lattice","page":"Helper types for groups","title":"SimplicialSets.Lattice","text":"Lattice{N} <: AbstractVector{Int}\n\nLattice(t::NTuple{N,Integer}) where N -> Lattice{N}\nLattice(x::Integer...) -> Lattice\n\nA type representing elements in a lattice (free abelian group) of rank N.\n\nSee also Tuple(::Lattice).\n\nExamples\n\njulia> x, y = Lattice(1, 2, 3), Lattice(0, -1, 5)\n((1, 2, 3), (0, -1, 5))\n\njulia> x+y, x-y\n((1, 1, 8), (1, 3, -2))\n\njulia> 2*x\n(2, 4, 6)\n\njulia> zero(x)\n(0, 0, 0)\n\njulia> length(x)\n3\n\njulia> y[2]\n-1\n\njulia> a, z... = x; z\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"helpers/#Core.Tuple-Tuple{Lattice}","page":"Helper types for groups","title":"Core.Tuple","text":"Tuple(g::Lattice{N}) where N -> NTuple{N,Int}\n\nReturn the lattice element as a tuple of integers.\n\n\n\n\n\n","category":"method"}]
}
